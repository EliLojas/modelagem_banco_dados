"use strict";(self.webpackChunkdoc_modelagem_banco_dados=self.webpackChunkdoc_modelagem_banco_dados||[]).push([[9890],{3905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>N});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=n.createContext({}),d=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},l=function(e){var t=d(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",E={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=d(a),m=o,N=u["".concat(c,".").concat(m)]||u[m]||E[m]||r;return a?n.createElement(N,s(s({ref:t},l),{},{components:a})):n.createElement(N,s({ref:t},l))}));function N(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9092:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>l,toc:()=>E});var n=a(7462),o=a(7294),r=a(3905);function s(e){let{functions:t}=e;const[a,n]=(0,o.useState)(""),r=t.filter((e=>Object.values(e).some((e=>e.toString().toLowerCase().includes(a.toLowerCase())))));return o.createElement("div",{className:"container"},o.createElement("div",{className:"padding--sm"},o.createElement("input",{className:"navbar__search-input",type:"text",placeholder:"Pesquisar dom\xednio",value:a,onChange:e=>n(e.target.value)})),o.createElement("div",{className:"row"},o.createElement("table",null,o.createElement("thead",null,o.createElement("tr",null,o.createElement("th",null,"Nome"),o.createElement("th",null,"Schema"),o.createElement("th",null,"Tipo de Retorno"),o.createElement("th",{style:{width:"20px"}},"Linguagem"),o.createElement("th",null,"Coment\xe1rio"))),o.createElement("tbody",null,r.map(((e,t)=>o.createElement("tr",{key:t},o.createElement("td",null,e["@name"]),o.createElement("td",null,e.schema["@name"]),o.createElement("td",null,e["return-type"].type["@name"]),o.createElement("td",null,e.language["@name"]),o.createElement("td",null,e.comment))))))))}const i=JSON.parse('[{"@name":"fun_trg_antes_atualizar_todas_tabelas","@window-func":"false","@returns-setof":"false","@behavior-type":"CALLED ON NULL INPUT","@function-type":"VOLATILE","@security-type":"SECURITY INVOKER","@parallel-type":"PARALLEL UNSAFE","@execution-cost":"1","@row-amount":"0","schema":{"@name":"public"},"role":{"@name":"postgres"},"comment":"Esta fun\xe7\xe3o tem o objetivo de fazer checagens e preencher campos obrigat\xf3rios todas vez que um registro sobrer altera\xe7\xe3o.","language":{"@name":"plpgsql"},"return-type":{"type":{"@name":"trigger","@length":"0"}},"definition":"BEGIN\\n\\t/* Usado para n\xe3o executar a trigger quando estiver fazendo replica\xe7\xe3o. Nunca desative as trigger, pois certeza que vai dar merda. */ \\n\\tIF ( SELECT COALESCE( current_setting(\'sessao.usuario.replicacao\', TRUE), \'0\') = \'1\' ) THEN RETURN NULL; END IF;\\n\\t\\n\\t-- Primeiro checa se teve uma altera\xe7\xe3o real\\n\\tIF (NEW != OLD) THEN\\n\\t\\t  \\n\\t\\tNEW.alterado_usuario := CURRENT_USER;\\n\\t\\tNEW.alterado_em := timezone(\'utc\', CURRENT_TIMESTAMP);\\n\\tELSE\\n\\n\\t\\t-- Garante o preenchimento da data de altera\xe7\xe3o, pois esta coluna \xe9 indexada em todas as tabelas.\\n\\t\\tIF (NEW.alterado_em IS NULL) THEN\\n\\n\\t\\t\\tNEW.alterado_em := timezone(\'utc\', CURRENT_TIMESTAMP);\\n\\t\\tEND IF;\\n\\n\\t\\tIF (NEW.alterado_usuario IS NULL) THEN\\n\\n\\t\\t\\tNEW.alterado_usuario := CURRENT_USER;\\n\\t  \\tEND IF;\\n\\tEND IF;\\n\\n\\tRETURN NEW;\\nEND;"},{"@name":"fun_trg_gera_logger_todas_tabelas","@window-func":"false","@returns-setof":"false","@behavior-type":"CALLED ON NULL INPUT","@function-type":"VOLATILE","@security-type":"SECURITY INVOKER","@parallel-type":"PARALLEL UNSAFE","@execution-cost":"1","@row-amount":"0","schema":{"@name":"public"},"role":{"@name":"postgres"},"comment":"Fun\xe7\xe3o para salvar todas as altera\xe7\xf5es de dados que uma tabela sofrer.\\nEssas altera\xe7\xf5es podem ser de atualiza\xe7\xe3o e dele\xe7\xe3o de registros.","language":{"@name":"plpgsql"},"return-type":{"type":{"@name":"trigger","@length":"0"}},"definition":"DECLARE\\n\\tTIPO_LOG CHAR(1) := \'\';\\n\\tARQUIVO RECORD := NULL;\\n\\tID_REGISTRO_AFETADO BIGINT;\\n\\tCOLUNAS_ALTERADAS JSONB;\\n\\tCOLUNA RECORD;\\n\\tVALOR_COLUNA RECORD := NULL;\\n\\tDIF_NEW_OLD BOOLEAN;\\n\\nBEGIN\\n\\t/* Usado para n\xe3o executar a trigger quando estiver fazendo replica\xe7\xe3o. Nunca desative as trigger, pois certeza que vai dar merda. */ \\n\\tIF ( SELECT COALESCE( current_setting(\'sessao.usuario.replicacao\', TRUE), \'0\') = \'1\' ) THEN RETURN NULL; END IF;\\n\\n\\t/* Consulta na tabela ASTARQUI para verificar se a tabela que disparou a trigger n\xe3o precisa registrar log. */\\n\\tSELECT log_alteracao, log_delecao, salva_id_deletado\\n\\t\\tINTO ARQUIVO\\n\\t\\tFROM astarqui WHERE nome_arquivo = TG_RELNAME;\\n\\t\\n\\t/* Pega o tipo de opera\xe7\xe3o (Insert, Update, Delete). */\\n\\tTIPO_LOG = substring(TG_OP, 1, 1);\\n\\n\\tIF (TIPO_LOG = \'D\') THEN\\n\\t\\t\\n\\t\\tID_REGISTRO_AFETADO = OLD.id;\\n\\t\\t\\n\\t\\t/* Por padr\xe3o salva o ID que foi deletado. Caso contr\xe1rio basta cadastrar na tabela ASTARQUI\\n\\t\\to nome da tabela que n\xe3o deseja salvar o ID deletado e preencher o campo SALVA_ID_DELETADO com false. */\\n\\t\\tIF (ARQUIVO IS NULL) OR (ARQUIVO.salva_id_deletado) THEN\\n\\t\\t\\t\\n\\t\\t\\tINSERT INTO astregde ( schema_tabela, nome_arquivo, id_deletado, uuid_deletado )\\n\\t\\t\\tVALUES ( TG_TABLE_SCHEMA, TG_TABLE_NAME, ID_REGISTRO_AFETADO, OLD.uuid );\\n\\t\\tEND IF;\\n\\t\\t\\n\\tEND IF;\\n\\t\\n\\t/* Por padr\xe3o vai registrar o log das transa\xe7\xf5es. Caso n\xe3o queira registrar o log\\n\\tde uma tabela basta ir na tabela ASTARQUI e cadastrar a tabela que n\xe3o deseja registrar\\n\\tlog e marcar o campo ASTARQUI.LOG_... com false. */\\n\\tIF (TIPO_LOG <> \'\')\\n\\t\\tAND (TIPO_LOG IN (\'D\', \'U\'))\\n\\t\\tAND (\\n\\t\\t\\tARQUIVO IS NULL\\n\\t\\t\\tOR ARQUIVO.log_alteracao\\n\\t\\t\\tOR ARQUIVO.log_delecao\\n\\t\\t\\t) THEN\\n\\t\\t\\n\\t\\tCOLUNAS_ALTERADAS := \'{}\';\\n\\t\\t\\n\\t\\t/* Busca todas as colunas da tabela da trigger. Busca as colunas da tabela da trigger.\\n\\t\\tUtiliza o cat\xe1logo do PostgreSQL (pg_attribute) para obter as informa\xe7\xf5es das colunas da tabela. \\n\\t\\tEssa abordagem evita a necessidade de executar consultas din\xe2micas para recuperar as \\n\\t\\tcolunas da tabela a cada vez que a fun\xe7\xe3o de trigger \xe9 acionada. */\\n\\t  \\t\\n\\t  \\t/* Pega o nome de todas as colunas e o tipo de dados delas. */\\n\\t\\tFOR COLUNA IN SELECT attname, format_type(atttypid, atttypmod) AS tipoDados\\n\\t\\t\\tFROM pg_attribute\\n\\t\\t  \\tWHERE attrelid = TG_RELID\\n\\t\\t  \\t\\tAND NOT attisdropped\\n\\t\\t  \\t\\tAND attnum > 0\\n\\t\\tLOOP\\n\\t\\t\\tVALOR_COLUNA := NULL;\\n\\t\\t\\t\\n\\t\\t\\tEXECUTE format(\'SELECT to_jsonb($1.%I::%s) AS valor\', COLUNA.attname, COLUNA.tipoDados)\\n\\t\\t        USING OLD\\n\\t\\t        INTO VALOR_COLUNA;\\n\\t\\t\\t\\n\\t\\t\\tIF (TIPO_LOG = \'D\') AND (VALOR_COLUNA.valor IS NOT NULL) THEN \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tCOLUNAS_ALTERADAS = COLUNAS_ALTERADAS || jsonb_build_object(COLUNA.attname, VALOR_COLUNA.valor);\\n\\t\\t\\t\\n\\t\\t\\tELSEIF (TIPO_LOG = \'U\') THEN\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* Checa se existe o NEW \xe9 diferente do OLD, para salvar somente o que foi alterado. */\\n\\t       \\t\\tEXECUTE format(\'SELECT ($1).%I IS DISTINCT FROM ($2).%I\', COLUNA.attname, COLUNA.attname)\\n\\t\\t\\t        USING OLD, NEW\\n\\t\\t\\t        INTO DIF_NEW_OLD;\\n\\t\\t       \\t\\n\\t\\t       \\tIF (DIF_NEW_OLD) THEN\\n\\t\\t       \\t\\n\\t\\t       \\t\\tCOLUNAS_ALTERADAS = COLUNAS_ALTERADAS || jsonb_build_object(COLUNA.attname, VALOR_COLUNA.valor);\\n\\t\\t       \\tEND IF;\\n\\t\\t\\tEND IF;\\n\\t\\tEND LOOP;\\n\\t  \\t\\n\\t\\tIF TIPO_LOG != \'D\' THEN ID_REGISTRO_AFETADO = NEW.id; END IF;\\n\\t\\t\\n\\t\\tINSERT INTO logger_tabela.astlogta( tipo_log, aplicacao, schema_tabela, tabela, id_registro, descricao_log )\\n\\t\\tVALUES( TIPO_LOG, current_setting(\'application_name\'), TG_TABLE_SCHEMA, TG_TABLE_NAME, ID_REGISTRO_AFETADO, COLUNAS_ALTERADAS );\\n\\tEND IF;\\n\\t\\n\\t/* Checa qual \xe9 o tipo de opera\xe7\xe3o para poder retornar o OLD ou o NEW. */\\n\\tIF TIPO_LOG = \'D\' THEN\\n\\t\\tRETURN OLD;\\n\\tELSE\\n\\t\\tRETURN NEW;\\n\\tEND IF;\\nEND;"},{"@name":"fun_trg_gera_codigo_pessoa","@window-func":"false","@returns-setof":"false","@behavior-type":"CALLED ON NULL INPUT","@function-type":"VOLATILE","@security-type":"SECURITY INVOKER","@parallel-type":"PARALLEL UNSAFE","@execution-cost":"1","@row-amount":"0","schema":{"@name":"public"},"role":{"@name":"postgres"},"language":{"@name":"plpgsql"},"return-type":{"type":{"@name":"trigger","@length":"0"}},"definition":"BEGIN\\n\\t/* Usado para n\xe3o executar a trigger quando estiver fazendo replica\xe7\xe3o. Nunca desative as trigger, pois certeza que vai dar merda. */ \\n\\tIF ( SELECT COALESCE( current_setting(\'sessao.usuario.replicacao\', TRUE), \'0\') = \'1\' ) THEN RETURN NULL; END IF;\\n\\n\\tIF ( TG_OP = \'INSERT\' ) THEN\\n\\t\\n\\t\\tIF ( NEW.eh_cliente ) THEN \\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_cliente := nextval( \'seq_cftpesso_cliente\' ); \\n\\t\\tEND IF;\\n\\t\\t\\n\\t\\tIF ( NEW.eh_fornecedor ) THEN\\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_fornecedor := nextval( \'seq_cftpesso_fornecedor\' );\\n\\t\\tEND IF;\\n\\t\\t\\n\\t\\tIF ( NEW.eh_funcionario ) THEN\\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_funcionario := nextval( \'seq_cftpesso_funcionario\' );\\n\\t\\tEND IF;\\n\\n\\t\\tIF ( NEW.eh_fornecedor ) THEN\\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_transportadora := nextval( \'seq_cftpesso_transportadora\' ); \\n\\t\\tEND IF;\\n\\t\\t\\n\\tELSIF ( TG_OP = \'UPDATE\' ) THEN\\n\\t\\n\\t\\tIF ( NEW.eh_cliente ) AND ( !OLD.eh_cliente ) \\n\\t\\t\\tAND ( ( NEW.codigo_cliente IS NULL ) OR ( NEW.codigo_cliente = \'\' ) ) THEN \\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_cliente := nextval( \'seq_cftpesso_cliente\' ); \\n\\t\\tEND IF;\\n\\n\\t\\tIF ( NEW.eh_fornecedor ) AND ( !OLD.eh_fornecedor ) \\n\\t\\t\\tAND ( ( NEW.codigo_fornecedor IS NULL ) OR ( NEW.codigo_fornecedor = \'\' ) ) THEN \\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_cliente := nextval( \'seq_cftpesso_fornecedor\' ); \\n\\t\\tEND IF;\\n\\n\\t\\tIF ( NEW.eh_funcionario ) AND ( !OLD.eh_funcionario ) \\n\\t\\t\\tAND ( ( NEW.codigo_funcionario IS NULL ) OR ( NEW.codigo_funcionario = \'\' ) ) THEN \\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_cliente := nextval( \'seq_cftpesso_funcionario\' ); \\n\\t\\tEND IF;\\n\\n\\t\\tIF ( NEW.eh_transportadora ) AND ( !OLD.eh_transportadora ) \\n\\t\\t\\tAND ( ( NEW.codigo_transportadora IS NULL ) OR ( NEW.codigo_transportadora = \'\' ) ) THEN \\n\\t\\t\\t\\n\\t\\t\\tNEW.codigo_cliente := nextval( \'seq_cftpesso_transportadora\' ); \\n\\t\\tEND IF;\\n\\tEND IF;\\n\\n\\tRETURN NEW;\\nEND;"},{"@name":"fun_trg_impedir_exclusao_id_referenciado","@window-func":"false","@returns-setof":"false","@behavior-type":"CALLED ON NULL INPUT","@function-type":"VOLATILE","@security-type":"SECURITY INVOKER","@parallel-type":"PARALLEL UNSAFE","@execution-cost":"1","@row-amount":"0","schema":{"@name":"public"},"role":{"@name":"postgres"},"comment":"Esta fun\xe7\xe3o tem o objetivo de evitar a exclus\xe3o de registros em uma tabela que possui relacionamentos de chave estrangeira com outras tabelas. Quando voc\xea quer excluir um registro em um banco de dados, \xe9 importante ter certeza de que esse registro n\xe3o est\xe1 sendo usado por outros registros em diferentes partes do banco de dados. \\n\\nEla \xe9 projetada para ser uma fun\xe7\xe3o de gatilho (trigger) gen\xe9rica que pode ser usada em v\xe1rias situa\xe7\xf5es, em que o objetivo \xe9 garantir a integridade referencial dos dados no banco de dados.\\n\\nA fun\xe7\xe3o atua da seguinte forma:\\n\\n1. Recebe dois par\xe2metros como entrada:\\n   - `lista_nomes_tabelas`: Um array com os nomes das tabelas relacionadas que cont\xe9m os registros que podem estar referenciando o registro a ser exclu\xeddo. Ou seja, o lugar (tabela) onde o ID do registro a ser deletado est\xe1 atualemnte.\\n\\n2. A fun\xe7\xe3o verifica se existem registros nas tabelas relacionadas que referenciam o registro que est\xe1 prestes a ser exclu\xeddo.\\n\\n3. Se a fun\xe7\xe3o encontrar registros relacionados, ela lan\xe7a uma exce\xe7\xe3o com uma mensagem de erro indicando que n\xe3o \xe9 poss\xedvel excluir o registro, uma vez que existem registros dependentes na tabela relacionada. Isso impede a exclus\xe3o e mant\xe9m a integridade referencial dos dados.\\n\\nO objetivo principal dessa fun\xe7\xe3o \xe9 ajudar a garantir que n\xe3o ocorram exclus\xf5es acidentais que quebrariam a integridade dos dados em seu banco de dados, mantendo a consist\xeancia dos relacionamentos de chave estrangeira. Ela fornece uma maneira flex\xedvel e reutiliz\xe1vel de implementar essa l\xf3gica de verifica\xe7\xe3o em diferentes tabelas que precisam dessa prote\xe7\xe3o.","language":{"@name":"plpgsql"},"return-type":{"type":{"@name":"trigger","@length":"0"}},"definition":"DECLARE\\n\\tlista_nomes_tabelas public.dm_nome_arquivo[] := TG_ARGV[0];\\n\\tnome_tabela public.dm_nome_arquivo;\\n\\texistente_relacionamento BOOLEAN;\\nBEGIN\\n\\t/* Usado para n\xe3o executar a trigger quando estiver fazendo replica\xe7\xe3o. Nunca desative as trigger, pois certeza que vai dar merda. */ \\n\\tIF ( SELECT COALESCE( current_setting(\'sessao.usuario.replicacao\', TRUE), \'0\') = \'1\' ) THEN RETURN NULL; END IF;\\n\\n\\t/* Passa por todas as tabelas relacionadas. */\\n\\tFOREACH nome_tabela IN ARRAY lista_nomes_tabelas\\n\\tLOOP\\n\\t\\t-- Verifique se existem registros na tabela relacionada.\\n\\t\\tEXECUTE \'SELECT 1 FROM \' || nome_tabela || \' WHERE id_\' || TG_TABLE_NAME || \' = $1\' INTO existente_relacionamento USING OLD.id;\\n\\t\\t\\n\\t\\tIF (existente_relacionamento) THEN\\n\\t\\t\\t-- Mostra mensagem de erro se existir alguma tabela que use o registro.\\n\\t\\t\\tRAISE EXCEPTION USING ERRCODE = \'23503\', MESSAGE = format(\'N\xe3o \xe9 poss\xedvel excluir o registro com ID (%I). Este registro \xe9 utilizado na tabela %s, na coluna id_%s\', OLD.id, nome_tabela, TG_TABLE_NAME);\\n\\t\\tEND IF;\\n\\tEND LOOP;\\n\\n\\tRETURN OLD;\\nEND;"}]'),c={sidebar_position:1},d="Fun\xe7\xf5es",l={unversionedId:"objetos-banco-dados/functions",id:"objetos-banco-dados/functions",title:"Fun\xe7\xf5es",description:"Todos os dom\xednios criados para o banco de dados de produ\xe7\xe3o.",source:"@site/docs/objetos-banco-dados/functions.mdx",sourceDirName:"objetos-banco-dados",slug:"/objetos-banco-dados/functions",permalink:"/modelagem_banco_dados/docs/objetos-banco-dados/functions",draft:!1,editUrl:"https://github.com/EliLojas/modelagem_banco_dados/blob/main/doc-modelagem_banco_dados/docs/objetos-banco-dados/functions.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Dom\xednios",permalink:"/modelagem_banco_dados/docs/objetos-banco-dados/dominios"}},u={},E=[],m={toc:E},N="wrapper";function p(e){let{components:t,...a}=e;return(0,r.kt)(N,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"fun\xe7\xf5es"},"Fun\xe7\xf5es"),(0,r.kt)("p",null,"Todos os dom\xednios criados para o banco de dados de produ\xe7\xe3o."),(0,r.kt)(s,{functions:i,mdxType:"FunctionTable"}))}p.isMDXComponent=!0}}]);