[{"@name": "fun_trg_antes_atualizar_todas_tabelas", "@window-func": "false", "@returns-setof": "false", "@behavior-type": "CALLED ON NULL INPUT", "@function-type": "VOLATILE", "@security-type": "SECURITY INVOKER", "@parallel-type": "PARALLEL UNSAFE", "@execution-cost": "1", "@row-amount": "0", "schema": {"@name": "public"}, "role": {"@name": "postgres"}, "comment": "Esta função tem o objetivo de fazer checagens e preencher campos obrigatórios todas vez que um registro sobrer alteração.", "language": {"@name": "plpgsql"}, "return-type": {"type": {"@name": "trigger", "@length": "0"}}, "definition": "BEGIN\n\t/* Usado para não executar a trigger quando estiver fazendo replicação. Nunca desative as trigger, pois certeza que vai dar merda. */ \n\tIF ( SELECT COALESCE( current_setting('sessao.usuario.replicacao', TRUE), '0') = '1' ) THEN RETURN NULL; END IF;\n\t\n\t-- Primeiro checa se teve uma alteração real\n\tIF (NEW != OLD) THEN\n\t\t  \n\t\tNEW.alterado_usuario := CURRENT_USER;\n\t\tNEW.alterado_em := timezone('utc', CURRENT_TIMESTAMP);\n\tELSE\n\n\t\t-- Garante o preenchimento da data de alteração, pois esta coluna é indexada em todas as tabelas.\n\t\tIF (NEW.alterado_em IS NULL) THEN\n\n\t\t\tNEW.alterado_em := timezone('utc', CURRENT_TIMESTAMP);\n\t\tEND IF;\n\n\t\tIF (NEW.alterado_usuario IS NULL) THEN\n\n\t\t\tNEW.alterado_usuario := CURRENT_USER;\n\t  \tEND IF;\n\tEND IF;\n\n\tRETURN NEW;\nEND;"}, {"@name": "fun_trg_gera_logger_todas_tabelas", "@window-func": "false", "@returns-setof": "false", "@behavior-type": "CALLED ON NULL INPUT", "@function-type": "VOLATILE", "@security-type": "SECURITY INVOKER", "@parallel-type": "PARALLEL UNSAFE", "@execution-cost": "1", "@row-amount": "0", "schema": {"@name": "public"}, "role": {"@name": "postgres"}, "comment": "Função para salvar todas as alterações de dados que uma tabela sofrer.\nEssas alterações podem ser de atualização e deleção de registros.", "language": {"@name": "plpgsql"}, "return-type": {"type": {"@name": "trigger", "@length": "0"}}, "definition": "DECLARE\n\tTIPO_LOG CHAR(1) := '';\n\tARQUIVO RECORD := NULL;\n\tID_REGISTRO_AFETADO BIGINT;\n\tCOLUNAS_ALTERADAS JSONB;\n\tCOLUNA RECORD;\n\tVALOR_COLUNA RECORD := NULL;\n\tDIF_NEW_OLD BOOLEAN;\n\nBEGIN\n\t/* Usado para não executar a trigger quando estiver fazendo replicação. Nunca desative as trigger, pois certeza que vai dar merda. */ \n\tIF ( SELECT COALESCE( current_setting('sessao.usuario.replicacao', TRUE), '0') = '1' ) THEN RETURN NULL; END IF;\n\n\t/* Consulta na tabela ASTARQUI para verificar se a tabela que disparou a trigger não precisa registrar log. */\n\tSELECT log_alteracao, log_delecao, salva_id_deletado\n\t\tINTO ARQUIVO\n\t\tFROM astarqui WHERE nome_arquivo = TG_RELNAME;\n\t\n\t/* Pega o tipo de operação (Insert, Update, Delete). */\n\tTIPO_LOG = substring(TG_OP, 1, 1);\n\n\tIF (TIPO_LOG = 'D') THEN\n\t\t\n\t\tID_REGISTRO_AFETADO = OLD.id;\n\t\t\n\t\t/* Por padrão salva o ID que foi deletado. Caso contrário basta cadastrar na tabela ASTARQUI\n\t\to nome da tabela que não deseja salvar o ID deletado e preencher o campo SALVA_ID_DELETADO com false. */\n\t\tIF (ARQUIVO IS NULL) OR (ARQUIVO.salva_id_deletado) THEN\n\t\t\t\n\t\t\tINSERT INTO astregde ( schema_tabela, nome_arquivo, id_deletado, uuid_deletado )\n\t\t\tVALUES ( TG_TABLE_SCHEMA, TG_TABLE_NAME, ID_REGISTRO_AFETADO, OLD.uuid );\n\t\tEND IF;\n\t\t\n\tEND IF;\n\t\n\t/* Por padrão vai registrar o log das transações. Caso não queira registrar o log\n\tde uma tabela basta ir na tabela ASTARQUI e cadastrar a tabela que não deseja registrar\n\tlog e marcar o campo ASTARQUI.LOG_... com false. */\n\tIF (TIPO_LOG <> '')\n\t\tAND (TIPO_LOG IN ('D', 'U'))\n\t\tAND (\n\t\t\tARQUIVO IS NULL\n\t\t\tOR ARQUIVO.log_alteracao\n\t\t\tOR ARQUIVO.log_delecao\n\t\t\t) THEN\n\t\t\n\t\tCOLUNAS_ALTERADAS := '{}';\n\t\t\n\t\t/* Busca todas as colunas da tabela da trigger. Busca as colunas da tabela da trigger.\n\t\tUtiliza o catálogo do PostgreSQL (pg_attribute) para obter as informações das colunas da tabela. \n\t\tEssa abordagem evita a necessidade de executar consultas dinâmicas para recuperar as \n\t\tcolunas da tabela a cada vez que a função de trigger é acionada. */\n\t  \t\n\t  \t/* Pega o nome de todas as colunas e o tipo de dados delas. */\n\t\tFOR COLUNA IN SELECT attname, format_type(atttypid, atttypmod) AS tipoDados\n\t\t\tFROM pg_attribute\n\t\t  \tWHERE attrelid = TG_RELID\n\t\t  \t\tAND NOT attisdropped\n\t\t  \t\tAND attnum > 0\n\t\tLOOP\n\t\t\tVALOR_COLUNA := NULL;\n\t\t\t\n\t\t\tEXECUTE format('SELECT to_jsonb($1.%I::%s) AS valor', COLUNA.attname, COLUNA.tipoDados)\n\t\t        USING OLD\n\t\t        INTO VALOR_COLUNA;\n\t\t\t\n\t\t\tIF (TIPO_LOG = 'D') AND (VALOR_COLUNA.valor IS NOT NULL) THEN \n\t\t\t\t\n\t\t\t\tCOLUNAS_ALTERADAS = COLUNAS_ALTERADAS || jsonb_build_object(COLUNA.attname, VALOR_COLUNA.valor);\n\t\t\t\n\t\t\tELSEIF (TIPO_LOG = 'U') THEN\n\t\t\t\t\n\t\t\t\t/* Checa se existe o NEW é diferente do OLD, para salvar somente o que foi alterado. */\n\t       \t\tEXECUTE format('SELECT ($1).%I IS DISTINCT FROM ($2).%I', COLUNA.attname, COLUNA.attname)\n\t\t\t        USING OLD, NEW\n\t\t\t        INTO DIF_NEW_OLD;\n\t\t       \t\n\t\t       \tIF (DIF_NEW_OLD) THEN\n\t\t       \t\n\t\t       \t\tCOLUNAS_ALTERADAS = COLUNAS_ALTERADAS || jsonb_build_object(COLUNA.attname, VALOR_COLUNA.valor);\n\t\t       \tEND IF;\n\t\t\tEND IF;\n\t\tEND LOOP;\n\t  \t\n\t\tIF TIPO_LOG != 'D' THEN ID_REGISTRO_AFETADO = NEW.id; END IF;\n\t\t\n\t\tINSERT INTO logger_tabela.astlogta( tipo_log, aplicacao, schema_tabela, tabela, id_registro, descricao_log )\n\t\tVALUES( TIPO_LOG, current_setting('application_name'), TG_TABLE_SCHEMA, TG_TABLE_NAME, ID_REGISTRO_AFETADO, COLUNAS_ALTERADAS );\n\tEND IF;\n\t\n\t/* Checa qual é o tipo de operação para poder retornar o OLD ou o NEW. */\n\tIF TIPO_LOG = 'D' THEN\n\t\tRETURN OLD;\n\tELSE\n\t\tRETURN NEW;\n\tEND IF;\nEND;"}, {"@name": "fun_trg_gera_codigo_pessoa", "@window-func": "false", "@returns-setof": "false", "@behavior-type": "CALLED ON NULL INPUT", "@function-type": "VOLATILE", "@security-type": "SECURITY INVOKER", "@parallel-type": "PARALLEL UNSAFE", "@execution-cost": "1", "@row-amount": "0", "schema": {"@name": "public"}, "role": {"@name": "postgres"}, "language": {"@name": "plpgsql"}, "return-type": {"type": {"@name": "trigger", "@length": "0"}}, "definition": "BEGIN\n\t/* Usado para não executar a trigger quando estiver fazendo replicação. Nunca desative as trigger, pois certeza que vai dar merda. */ \n\tIF ( SELECT COALESCE( current_setting('sessao.usuario.replicacao', TRUE), '0') = '1' ) THEN RETURN NULL; END IF;\n\n\tIF ( TG_OP = 'INSERT' ) THEN\n\t\n\t\tIF ( NEW.eh_cliente ) THEN \n\t\t\t\n\t\t\tNEW.codigo_cliente := nextval( 'seq_cftpesso_cliente' ); \n\t\tEND IF;\n\t\t\n\t\tIF ( NEW.eh_fornecedor ) THEN\n\t\t\t\n\t\t\tNEW.codigo_fornecedor := nextval( 'seq_cftpesso_fornecedor' );\n\t\tEND IF;\n\t\t\n\t\tIF ( NEW.eh_funcionario ) THEN\n\t\t\t\n\t\t\tNEW.codigo_funcionario := nextval( 'seq_cftpesso_funcionario' );\n\t\tEND IF;\n\n\t\tIF ( NEW.eh_fornecedor ) THEN\n\t\t\t\n\t\t\tNEW.codigo_transportadora := nextval( 'seq_cftpesso_transportadora' ); \n\t\tEND IF;\n\t\t\n\tELSIF ( TG_OP = 'UPDATE' ) THEN\n\t\n\t\tIF ( NEW.eh_cliente ) AND ( !OLD.eh_cliente ) \n\t\t\tAND ( ( NEW.codigo_cliente IS NULL ) OR ( NEW.codigo_cliente = '' ) ) THEN \n\t\t\t\n\t\t\tNEW.codigo_cliente := nextval( 'seq_cftpesso_cliente' ); \n\t\tEND IF;\n\n\t\tIF ( NEW.eh_fornecedor ) AND ( !OLD.eh_fornecedor ) \n\t\t\tAND ( ( NEW.codigo_fornecedor IS NULL ) OR ( NEW.codigo_fornecedor = '' ) ) THEN \n\t\t\t\n\t\t\tNEW.codigo_cliente := nextval( 'seq_cftpesso_fornecedor' ); \n\t\tEND IF;\n\n\t\tIF ( NEW.eh_funcionario ) AND ( !OLD.eh_funcionario ) \n\t\t\tAND ( ( NEW.codigo_funcionario IS NULL ) OR ( NEW.codigo_funcionario = '' ) ) THEN \n\t\t\t\n\t\t\tNEW.codigo_cliente := nextval( 'seq_cftpesso_funcionario' ); \n\t\tEND IF;\n\n\t\tIF ( NEW.eh_transportadora ) AND ( !OLD.eh_transportadora ) \n\t\t\tAND ( ( NEW.codigo_transportadora IS NULL ) OR ( NEW.codigo_transportadora = '' ) ) THEN \n\t\t\t\n\t\t\tNEW.codigo_cliente := nextval( 'seq_cftpesso_transportadora' ); \n\t\tEND IF;\n\tEND IF;\n\n\tRETURN NEW;\nEND;"}, {"@name": "fun_trg_impedir_exclusao_id_referenciado", "@window-func": "false", "@returns-setof": "false", "@behavior-type": "CALLED ON NULL INPUT", "@function-type": "VOLATILE", "@security-type": "SECURITY INVOKER", "@parallel-type": "PARALLEL UNSAFE", "@execution-cost": "1", "@row-amount": "0", "schema": {"@name": "public"}, "role": {"@name": "postgres"}, "comment": "Esta função tem o objetivo de evitar a exclusão de registros em uma tabela que possui relacionamentos de chave estrangeira com outras tabelas. Quando você quer excluir um registro em um banco de dados, é importante ter certeza de que esse registro não está sendo usado por outros registros em diferentes partes do banco de dados. \n\nEla é projetada para ser uma função de gatilho (trigger) genérica que pode ser usada em várias situações, em que o objetivo é garantir a integridade referencial dos dados no banco de dados.\n\nA função atua da seguinte forma:\n\n1. Recebe dois parâmetros como entrada:\n   - `lista_nomes_tabelas`: Um array com os nomes das tabelas relacionadas que contém os registros que podem estar referenciando o registro a ser excluído. Ou seja, o lugar (tabela) onde o ID do registro a ser deletado está atualemnte.\n\n2. A função verifica se existem registros nas tabelas relacionadas que referenciam o registro que está prestes a ser excluído.\n\n3. Se a função encontrar registros relacionados, ela lança uma exceção com uma mensagem de erro indicando que não é possível excluir o registro, uma vez que existem registros dependentes na tabela relacionada. Isso impede a exclusão e mantém a integridade referencial dos dados.\n\nO objetivo principal dessa função é ajudar a garantir que não ocorram exclusões acidentais que quebrariam a integridade dos dados em seu banco de dados, mantendo a consistência dos relacionamentos de chave estrangeira. Ela fornece uma maneira flexível e reutilizável de implementar essa lógica de verificação em diferentes tabelas que precisam dessa proteção.", "language": {"@name": "plpgsql"}, "return-type": {"type": {"@name": "trigger", "@length": "0"}}, "definition": "DECLARE\n\tlista_nomes_tabelas public.dm_nome_arquivo[] := TG_ARGV[0];\n\tnome_tabela public.dm_nome_arquivo;\n\texistente_relacionamento BOOLEAN;\nBEGIN\n\t/* Usado para não executar a trigger quando estiver fazendo replicação. Nunca desative as trigger, pois certeza que vai dar merda. */ \n\tIF ( SELECT COALESCE( current_setting('sessao.usuario.replicacao', TRUE), '0') = '1' ) THEN RETURN NULL; END IF;\n\n\t/* Passa por todas as tabelas relacionadas. */\n\tFOREACH nome_tabela IN ARRAY lista_nomes_tabelas\n\tLOOP\n\t\t-- Verifique se existem registros na tabela relacionada.\n\t\tEXECUTE 'SELECT 1 FROM ' || nome_tabela || ' WHERE id_' || TG_TABLE_NAME || ' = $1' INTO existente_relacionamento USING OLD.id;\n\t\t\n\t\tIF (existente_relacionamento) THEN\n\t\t\t-- Mostra mensagem de erro se existir alguma tabela que use o registro.\n\t\t\tRAISE EXCEPTION USING ERRCODE = '23503', MESSAGE = format('Não é possível excluir o registro com ID (%I). Este registro é utilizado na tabela %s, na coluna id_%s', OLD.id, nome_tabela, TG_TABLE_NAME);\n\t\tEND IF;\n\tEND LOOP;\n\n\tRETURN OLD;\nEND;"}]